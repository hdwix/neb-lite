<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Authentication API Tester</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family:
          system-ui,
          -apple-system,
          BlinkMacSystemFont,
          'Segoe UI',
          sans-serif;
      }
      body {
        margin: 0;
        padding: 24px;
        background: #0d1117;
        color: #f0f6fc;
      }
      h1,
      h2 {
        margin-top: 0;
      }
      section {
        border: 1px solid #30363d;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
        background: rgba(13, 17, 23, 0.85);
      }
      label {
        display: block;
        font-size: 0.85rem;
        margin-bottom: 4px;
        color: #9da5b4;
      }
      input,
      button,
      textarea,
      select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        margin-bottom: 12px;
        border-radius: 6px;
        border: 1px solid #30363d;
        background: #161b22;
        color: inherit;
      }
      button {
        cursor: pointer;
        border: 1px solid #238636;
        background: #238636;
        font-weight: 600;
      }
      button.secondary {
        background: transparent;
        border-color: #30363d;
      }
      pre {
        background: #161b22;
        border: 1px solid #30363d;
        padding: 12px;
        border-radius: 6px;
        overflow: auto;
        max-height: 240px;
        font-size: 0.9rem;
      }
      .stacked {
        display: grid;
        gap: 12px;
      }
      .inline {
        display: flex;
        gap: 8px;
      }
      .inline input,
      .inline button {
        flex: 1;
        margin-bottom: 0;
      }
      .two-column {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        align-items: start;
      }
      .panel {
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 12px;
        background: rgba(22, 27, 34, 0.6);
      }
      .inline button {
        flex: none;
        width: auto;
        padding-inline: 16px;
      }
      .badge {
        display: inline-flex;
        padding: 2px 6px;
        border-radius: 12px;
        background: #30363d;
        font-size: 0.75rem;
        color: #9da5b4;
        margin-left: 8px;
      }
      .muted {
        color: #8b949e;
        font-size: 0.8rem;
      }
      .logs {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 240px;
        overflow-y: auto;
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 12px;
        background: #161b22;
      }
      .log-entry {
        font-family:
          ui-monospace, SFMono-Regular, SFMono-Regular, 'Fira Code', monospace;
        font-size: 0.85rem;
        padding: 4px 6px;
        border-radius: 4px;
        background: rgba(35, 134, 54, 0.12);
      }
    </style>
  </head>
  <body>
    <main class="stacked">
      <header>
        <h1>
          Authentication Process Testing
          <span class="badge">IAM module</span>
        </h1>
        <p class="muted">
          Minimal controls to exercise OTP retrieval, verification, refresh, and
          logout flows. Requests automatically include credentials so tokens
          emitted in cookies stay attached to subsequent calls.
        </p>
      </header>

      <section>
        <h2>Environment</h2>
        <div class="stacked">
          <label for="baseUrl">Gateway base URL</label>
          <input
            id="baseUrl"
            type="url"
            value="http://localhost:3000/api/v1/gateway/auth"
            placeholder="http://localhost:3000/api/v1/gateway/auth"
          />
          <label for="clientType">Client type</label>
          <select id="clientType">
            <option value="RIDER">RIDER</option>
            <option value="DRIVER">DRIVER</option>
          </select>
          <div class="inline">
            <input
              id="authMsisdn"
              type="tel"
              placeholder="MSISDN / phone number"
            />
            <button id="rememberMsisdn" class="secondary">Remember</button>
          </div>
        </div>
      </section>

      <section>
        <h2>1. Request OTP</h2>
        <div class="stacked">
          <div class="inline">
            <button id="startSse">Start stream</button>
            <button id="stopSse" class="secondary">Stop</button>
          </div>
          <label for="otpSimulationToken"
            >x-otp-simulation-token header (SSE only)</label
          >
          <input
            id="otpSimulationToken"
            type="text"
            placeholder="Provide simulation token for OTP stream"
          />
          <div class="two-column">
            <div class="panel stacked">
              <button id="requestOtp" type="button">
                Call /gateway/auth/request-otp
              </button>
              <pre id="requestOtpResult">{}</pre>
              <button id="simulateOtp" class="secondary" type="button">
                Call /gateway/auth/simulate/:msisdn/get-otp
              </button>
              <pre id="simulateOtpResult">{}</pre>
            </div>
            <div class="panel stacked">
              <label>Received OTP token</label>
              <pre id="latestOtpToken">Waiting for stream…</pre>
              <label class="muted">Last SSE payload</label>
              <pre id="latestOtpRaw">{}</pre>
            </div>
          </div>
          <div>
            <span class="muted">Incoming OTP messages</span>
            <div id="sseLog" class="logs"></div>
          </div>
        </div>
      </section>

      <section>
        <h2>2. Verify OTP</h2>
        <div class="stacked">
          <input id="otpCode" type="text" placeholder="Enter OTP code" />
          <button id="verifyOtp">Call /gateway/auth/verify-otp</button>
          <pre id="verifyOtpResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>3. Refresh Tokens</h2>
        <div class="stacked">
          <input
            id="refreshToken"
            type="text"
            placeholder="Paste refresh token value"
          />
          <button id="refreshTokens">Call /gateway/auth/refresh-token</button>
          <pre id="refreshResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>4. Logout</h2>
        <div class="stacked">
          <input
            id="logoutRefreshToken"
            type="text"
            placeholder="Refresh token"
          />
          <button id="logout">Call /gateway/auth/logout</button>
          <pre id="logoutResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Token snapshot</h2>
        <div class="stacked">
          <button id="refreshTokenSnapshot">Read cookies</button>
          <pre id="tokenSnapshot">{}</pre>
        </div>
      </section>
    </main>

    <script>
      const state = {
        sse: null,
        msisdn: '',
      };

      const baseUrlEl = document.getElementById('baseUrl');
      const msisdnEl = document.getElementById('authMsisdn');
      const otpResultEl = document.getElementById('requestOtpResult');
      const verifyResultEl = document.getElementById('verifyOtpResult');
      const refreshResultEl = document.getElementById('refreshResult');
      const logoutResultEl = document.getElementById('logoutResult');
      const tokenSnapshotEl = document.getElementById('tokenSnapshot');
      const sseLogEl = document.getElementById('sseLog');
      const simulateOtpResultEl = document.getElementById('simulateOtpResult');
      const otpSimulationTokenEl =
        document.getElementById('otpSimulationToken');
      const latestOtpTokenEl = document.getElementById('latestOtpToken');
      const latestOtpRawEl = document.getElementById('latestOtpRaw');
      const clientTypeEl = document.getElementById('clientType');

      function getBaseUrl() {
        return baseUrlEl.value.replace(/\/$/, '');
      }

      function getClientType() {
        return clientTypeEl.value;
      }

      function encodeMsisdnForPath(msisdn) {
        return encodeURIComponent(msisdn).replace(/%2B/g, '+');
      }

      function rememberMsisdn() {
        state.msisdn = msisdnEl.value.trim();
        localStorage.setItem('auth-msisdn', state.msisdn);
      }

      function loadMsisdn() {
        const cached = localStorage.getItem('auth-msisdn');
        if (cached) {
          state.msisdn = cached;
          msisdnEl.value = cached;
        }
      }

      function loadClientType() {
        const cachedType = localStorage.getItem('auth-client-type');
        if (cachedType) {
          clientTypeEl.value = cachedType;
        }
      }

      clientTypeEl.addEventListener('change', () => {
        localStorage.setItem('auth-client-type', getClientType());
      });

      function setResult(element, payload) {
        element.textContent = formatPayload(payload);
      }

      function formatPayload(payload) {
        if (payload instanceof Response) {
          return `${payload.status} ${payload.statusText}`;
        }
        if (typeof payload === 'string') {
          return payload;
        }
        try {
          return JSON.stringify(payload, null, 2);
        } catch (error) {
          return String(payload);
        }
      }

      async function requestJson(path, { method = 'GET', body, headers } = {}) {
        const url = `${getBaseUrl()}${path}`;
        console.log('url===');
        console.log(url);
        const options = {
          method,
          credentials: 'include',
          headers: {},
        };
        if (headers) {
          Object.assign(options.headers, headers);
        }
        if (body !== undefined) {
          options.body = typeof body === 'string' ? body : JSON.stringify(body);
          options.headers['Content-Type'] = 'application/json';
        } else if (!method.match(/^(GET|HEAD)$/i)) {
          options.headers['Content-Type'] = 'application/json';
        }

        let response;
        try {
          response = await fetch(url, options);
        } catch (error) {
          console.log('THIS');
          console.log(error);
          console.error(error);
          const detail =
            error instanceof Error ? error.message : 'Unknown network failure';
          throw new Error(`Network request failed: ${detail}`);
        }

        let data = null;
        try {
          data = await response.clone().json();
        } catch (error) {
          console.error(error);
          try {
            data = await response.text();
          } catch (textError) {
            console.error(textError);
          }
        }
        return { response, data };
      }

      async function postJson(path, body) {
        return requestJson(path, { method: 'POST', body });
      }

      function getSimulationToken() {
        return otpSimulationTokenEl.value.trim();
      }

      function extractOtpToken(payload) {
        if (!payload || typeof payload !== 'object') {
          return undefined;
        }
        return (
          payload.otpToken ||
          payload.token ||
          payload.otp ||
          payload.code ||
          payload.value
        );
      }

      function updateLatestOtpDisplays(payload) {
        if (payload === undefined || payload === null || payload === '') {
          latestOtpTokenEl.textContent = 'Waiting for stream…';
          latestOtpRawEl.textContent = '{}';
          return undefined;
        }

        let parsed = payload;
        if (typeof payload === 'string') {
          latestOtpRawEl.textContent = payload;
        } else {
          latestOtpRawEl.textContent = formatPayload(payload);
        }

        if (typeof payload === 'string') {
          try {
            parsed = JSON.parse(payload);
          } catch (error) {
            parsed = payload;
          }
        }

        const token =
          typeof parsed === 'string' ? parsed : extractOtpToken(parsed);
        latestOtpTokenEl.textContent = token
          ? String(token)
          : typeof parsed === 'string'
            ? parsed
            : formatPayload(parsed);
        return token || (typeof parsed === 'string' ? parsed : undefined);
      }

      document
        .getElementById('rememberMsisdn')
        .addEventListener('click', (event) => {
          event.preventDefault();
          rememberMsisdn();
          refreshTokenSnapshot();
        });

      document
        .getElementById('requestOtp')
        .addEventListener('click', async () => {
          rememberMsisdn();
          const msisdn = state.msisdn;
          if (!msisdn) {
            return setResult(otpResultEl, 'Enter phone number first.');
          }
          try {
            const result = await requestJson('/request-otp', {
              method: 'POST',
              body: {
                msisdn,
                clientType: getClientType(),
              },
            });
            setResult(otpResultEl, result.data || result.response);
            const tokenFromResponse = extractOtpToken(result.data);
            if (tokenFromResponse) {
              otpSimulationTokenEl.value = tokenFromResponse;
            }
            updateLatestOtpDisplays(result.data);
          } catch (error) {
            setResult(otpResultEl, error.message);
          }
        });

      document
        .getElementById('simulateOtp')
        .addEventListener('click', async () => {
          rememberMsisdn();
          const phone = state.msisdn;
          if (!phone) {
            return setResult(simulateOtpResultEl, 'Enter phone number first.');
          }
          try {
            const result = await requestJson(
              `/simulate/${encodeMsisdnForPath(phone)}/get-otp`,
            );
            setResult(simulateOtpResultEl, result.data || result.response);
            const tokenFromResponse = extractOtpToken(result.data);
            if (tokenFromResponse) {
              otpSimulationTokenEl.value = tokenFromResponse;
            }
            updateLatestOtpDisplays(result.data);
          } catch (error) {
            setResult(simulateOtpResultEl, error.message);
          }
        });

      document
        .getElementById('verifyOtp')
        .addEventListener('click', async () => {
          rememberMsisdn();
          const phone = state.msisdn;
          const otpCode = document.getElementById('otpCode').value.trim();
          if (!phone || !otpCode) {
            return setResult(
              verifyResultEl,
              'Provide both phone number and OTP.',
            );
          }
          try {
            const result = await postJson('/verify-otp', {
              msisdn: phone,
              otpCode,
              clientType: getClientType(),
            });
            setResult(verifyResultEl, result.data || result.response);
          } catch (error) {
            setResult(verifyResultEl, error.message);
          } finally {
            refreshTokenSnapshot();
          }
        });

      document
        .getElementById('refreshTokens')
        .addEventListener('click', async () => {
          const refreshToken = document
            .getElementById('refreshToken')
            .value.trim();
          if (!refreshToken) {
            return setResult(refreshResultEl, 'Enter refresh token value.');
          }
          try {
            const result = await postJson('/refresh-token', {
              refreshToken,
            });
            setResult(refreshResultEl, result.data || result.response);
          } catch (error) {
            setResult(refreshResultEl, error.message);
          } finally {
            refreshTokenSnapshot();
          }
        });

      document.getElementById('logout').addEventListener('click', async () => {
        const refreshToken = document
          .getElementById('logoutRefreshToken')
          .value.trim();
        if (!refreshToken) {
          return setResult(logoutResultEl, 'Provide refresh token to log out.');
        }
        try {
          const result = await postJson('/logout', {
            refreshToken,
          });
          setResult(logoutResultEl, result.data || result.response);
        } catch (error) {
          setResult(logoutResultEl, error.message);
        } finally {
          refreshTokenSnapshot();
        }
      });

      function refreshTokenSnapshot() {
        const cookies = document.cookie
          .split(';')
          .map((cookie) => cookie.trim())
          .filter(Boolean);
        const pairs = Object.fromEntries(
          cookies.map((cookie) => {
            const [key, ...rest] = cookie.split('=');
            return [
              decodeURIComponent(key),
              decodeURIComponent(rest.join('=')),
            ];
          }),
        );
        setResult(tokenSnapshotEl, pairs);
      }

      document
        .getElementById('refreshTokenSnapshot')
        .addEventListener('click', refreshTokenSnapshot);

      function appendLog(message) {
        const entry = document.createElement('div');
        const timestamp = new Date().toISOString();
        entry.className = 'log-entry';
        entry.textContent = `[${timestamp}] ${message}`;
        sseLogEl.prepend(entry);
      }

      function closeStream({ reason } = {}) {
        if (state.sse?.abortController) {
          state.sse.abortController.abort();
        }
        if (state.sse) {
          state.sse = null;
          appendLog(reason || 'SSE connection closed');
        }
      }

      document
        .getElementById('startSse')
        .addEventListener('click', async () => {
          closeStream();
          rememberMsisdn();
          const msisdn = state.msisdn;
          if (!msisdn) {
            appendLog('Enter phone number before starting stream.');
            return;
          }
          const url = `${getBaseUrl()}/simulate/${encodeMsisdnForPath(
            msisdn,
          )}/get-otp`;
          const simulationToken = getSimulationToken();
          if (!simulationToken) {
            appendLog('Provide x-otp-simulation-token before starting stream.');
            return;
          }
          const headers = { Accept: 'text/event-stream' };
          headers['x-otp-simulation-token'] = simulationToken;
          const abortController = new AbortController();
          state.sse = { abortController };
          appendLog(`Connecting to ${url}`);
          try {
            const response = await fetch(url, {
              method: 'GET',
              headers,
              credentials: 'include',
              signal: abortController.signal,
            });
            if (!response.ok) {
              closeStream({
                reason: `SSE connection failed: ${response.status} ${response.statusText}`,
              });
              return;
            }
            if (!response.body) {
              closeStream({ reason: 'SSE response did not include a body.' });
              return;
            }
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            async function readStream() {
              while (true) {
                const { value, done } = await reader.read();
                if (done) {
                  buffer += decoder.decode();
                  buffer = processSseBuffer(buffer, handleSseMessage);
                  if (buffer.trim()) {
                    handleSseMessage(buffer);
                  }
                  appendLog('SSE stream ended by server.');
                  state.sse = null;
                  return;
                }
                buffer += decoder.decode(value, { stream: true });
                buffer = processSseBuffer(buffer, handleSseMessage);
              }
            }
            await readStream();
          } catch (error) {
            if (error.name === 'AbortError') {
              appendLog('SSE connection aborted.');
            } else {
              appendLog(`SSE connection error: ${error.message}`);
            }
          } finally {
            if (state.sse?.abortController === abortController) {
              state.sse = null;
            }
          }
        });

      document
        .getElementById('stopSse')
        .addEventListener('click', () => closeStream());

      function processSseBuffer(buffer, callback) {
        while (buffer.includes('\n\n') || buffer.includes('\r\n\r\n')) {
          let delimiter = '\n\n';
          let index = buffer.indexOf(delimiter);
          if (index === -1) {
            delimiter = '\r\n\r\n';
            index = buffer.indexOf(delimiter);
          }
          if (index === -1) {
            break;
          }
          const rawEvent = buffer.slice(0, index);
          buffer = buffer.slice(index + delimiter.length);
          callback(rawEvent);
        }
        return buffer;
      }

      function handleSseMessage(rawEvent) {
        if (!rawEvent.trim()) {
          return;
        }
        const lines = rawEvent.split(/\r?\n/);
        const dataLines = [];
        for (const line of lines) {
          if (line.startsWith('data:')) {
            dataLines.push(line.slice(5).trimStart());
          }
        }
        if (!dataLines.length) {
          return;
        }
        const message = dataLines.join('\n');
        appendLog(message || '[empty message]');
        let parsed = message;
        if (typeof message === 'string') {
          try {
            parsed = JSON.parse(message);
          } catch (error) {
            parsed = message;
          }
        }
        if (parsed && typeof parsed === 'object') {
          const streamToken = extractOtpToken(parsed);
          if (streamToken) {
            otpSimulationTokenEl.value = streamToken;
          }
        }
        updateLatestOtpDisplays(message);
      }

      loadClientType();
      loadMsisdn();
      refreshTokenSnapshot();
      updateLatestOtpDisplays();
    </script>
  </body>
</html>
