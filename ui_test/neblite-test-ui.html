<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>OTP Request & SSE Monitor</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      :root {
        --bg: #0f172a;
        --card: #111827;
        --muted: #9ca3af;
        --text: #e5e7eb;
        --accent: #22d3ee;
        --ok: #22c55e;
        --err: #ef4444;
        --border: #1f2937;
        --btn: #1f2937;
        --btnh: #374151;
        --input: #0b1220;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: linear-gradient(180deg, #0b1220, #0f172a);
        color: var(--text);
        font:
          14px/1.4 system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Inter,
          'Helvetica Neue',
          Arial,
          'Noto Sans',
          'Apple Color Emoji',
          'Segoe UI Emoji';
      }
      header {
        padding: 18px 22px;
        border-bottom: 1px solid var(--border);
        backdrop-filter: blur(6px);
        position: sticky;
        top: 0;
        z-index: 5;
      }
      header h1 {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.3px;
      }
      header .sub {
        color: var(--muted);
        font-size: 12px;
      }
      .wrap {
        display: grid;
        grid-template-columns: 420px 1fr;
        gap: 16px;
        padding: 16px;
        height: calc(100% - 66px);
      }
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        overflow: hidden;
      }
      .section {
        padding: 16px;
      }
      .card h2 {
        margin: 0.2rem 0 1rem;
        font-size: 14px;
        color: #cbd5e1;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      input[type='text'],
      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: var(--input);
        color: var(--text);
        outline: none;
      }
      input::placeholder {
        color: #6b7280;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .actions {
        display: flex;
        gap: 8px;
        margin-top: 6px;
        flex-wrap: wrap;
      }
      button {
        appearance: none;
        border: 1px solid var(--border);
        background: var(--btn);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 10px;
        cursor: pointer;
        transition:
          0.18s transform,
          0.18s background;
      }
      button:hover {
        background: var(--btnh);
      }
      button.primary {
        border-color: #0ea5b7;
        background: #0b3a43;
      }
      button.success {
        border-color: #14532d;
        background: #063114;
      }
      button.warn {
        border-color: #7f1d1d;
        background: #3a0b0b;
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
      }
      .log {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .log-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        background: #0b1220;
      }
      .log-toolbar .status {
        font-size: 12px;
        color: var(--muted);
      }
      .log-body {
        padding: 0;
        height: 100%;
        overflow: auto;
        background: #0b0f1a;
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono',
          monospace;
        font-size: 12px;
      }
      .line {
        padding: 8px 12px;
        border-bottom: 1px dashed #1e293b;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .line.ok {
        color: #bbf7d0;
      }
      .line.err {
        color: #fecaca;
      }
      .line.dim {
        color: #9ca3af;
      }
      .footer {
        padding: 8px 16px;
        border-top: 1px solid var(--border);
        color: var(--muted);
        font-size: 11px;
      }
      code.kv {
        background: #0b1220;
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
      }
      .two-col {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      @media (max-width: 980px) {
        .wrap {
          grid-template-columns: 1fr;
          height: auto;
        }
        .log-body {
          height: 380px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>OTP Request & SSE Monitor</h1>
      <div class="sub">
        Sends <code class="kv">POST /api/v1/gateway/auth/request-otp</code> and
        listens to <code class="kv">SSE /simulate/:msisdn/get-otp</code> with a
        header <code class="kv">x-otp-simulation-token</code>.
      </div>
    </header>

    <div class="wrap">
      <!-- LEFT: Form -->
      <div class="card">
        <div class="section">
          <h2>Request OTP</h2>
          <div class="grid">
            <div>
              <label for="baseUrl">Base URL</label>
              <input
                id="baseUrl"
                type="text"
                placeholder="http://localhost:3000"
              />
            </div>
            <div>
              <label for="msisdn">MSISDN / Phone Number</label>
              <input id="msisdn" type="text" placeholder="+62812xxxxxxx" />
            </div>
            <div class="two-col">
              <div>
                <label for="clientType">Client Type</label>
                <input
                  id="clientType"
                  type="text"
                  placeholder="RIDER | DRIVER"
                />
              </div>
              <div>
                <label for="sseToken">SSE Token (x-otp-simulation-token)</label>
                <input
                  id="sseToken"
                  type="text"
                  placeholder="required by SSE endpoint"
                />
              </div>
            </div>
            <div class="actions">
              <button id="sendOtpBtn" class="primary">Send OTP Request</button>
              <button id="connectSseBtn" class="success">Connect SSE</button>
              <button id="disconnectSseBtn" class="warn">Disconnect SSE</button>
              <button id="clearLogBtn">Clear Log</button>
              <button id="saveBtn">Save Inputs</button>
              <button id="loadBtn">Load Inputs</button>
            </div>
            <div class="hint">
              • POST goes to
              <code class="kv">{base_url}/api/v1/gateway/auth/request-otp</code>
              with JSON.<br />
              • SSE connects to
              <code class="kv">{base_url}/simulate/{msisdn}/get-otp</code> and
              sends header <code class="kv">x-otp-simulation-token</code>.<br />
              • Requires CORS enabled on your server for both endpoints.
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: SSE Log -->
      <div class="card log">
        <div class="log-toolbar">
          <div>
            <strong>Events</strong>
            <span class="status" id="status">• disconnected</span>
          </div>
          <div class="row">
            <button id="copyBtn">Copy All</button>
          </div>
        </div>
        <div id="log" class="log-body" aria-live="polite"></div>
        <div class="footer">
          Tip: you can keep the SSE stream open while sending multiple OTP
          requests.
        </div>
      </div>
    </div>

    <script>
      // Elements
      const el = (id) => document.getElementById(id);
      const baseUrlEl = el('baseUrl');
      const msisdnEl = el('msisdn');
      const clientTypeEl = el('clientType');
      const sseTokenEl = el('sseToken');

      const sendOtpBtn = el('sendOtpBtn');
      const connectSseBtn = el('connectSseBtn');
      const disconnectSseBtn = el('disconnectSseBtn');
      const clearLogBtn = el('clearLogBtn');
      const copyBtn = el('copyBtn');
      const saveBtn = el('saveBtn');
      const loadBtn = el('loadBtn');

      const logBox = el('log');
      const statusEl = el('status');

      let sseAbortController = null;

      function line(text, cls = '') {
        const div = document.createElement('div');
        div.className = 'line ' + cls;
        div.textContent = text;
        logBox.appendChild(div);
        logBox.scrollTop = logBox.scrollHeight;
      }

      function validateInputs(requireTokenForSSE = false) {
        const base = (baseUrlEl.value || '').trim().replace(/\/+$/, '');
        const msisdn = (msisdnEl.value || '').trim();
        const clientType = (clientTypeEl.value || '').trim();
        const token = (sseTokenEl.value || '').trim();
        if (!base) {
          line('Please provide a base URL.', 'err');
          return null;
        }
        if (!msisdn) {
          line('Please provide MSISDN / phone number.', 'err');
          return null;
        }
        if (requireTokenForSSE && !token) {
          line('SSE token is required for the stream.', 'err');
          return null;
        }
        return { base, msisdn, clientType, token };
      }

      async function sendOtp() {
        const v = validateInputs(false);
        if (!v) return;

        const url = `${v.base}/api/v1/gateway/auth/request-otp`;
        const body = {
          msisdn: v.msisdn,
          clientType: v.clientType || undefined,
        };
        line(`→ POST ${url}\n${JSON.stringify(body, null, 2)}`, 'dim');

        try {
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            mode: 'cors',
            credentials: 'omit',
          });

          const contentType = res.headers.get('content-type') || '';
          let payload;
          if (contentType.includes('application/json')) {
            payload = await res.json();
          } else {
            payload = await res.text();
          }

          if (res.ok) {
            line(`✓ OTP request sent for msisdn : ${msisdnEl.value}`, 'ok');
          } else {
            line(`✗ OTP request failed for msisdn : ${msisdnEl.value}`, 'err');
          }
        } catch (err) {
          line(`✗ Network/Fetch error: ${err}`, 'err');
        }
      }

      function setStatus(txt) {
        statusEl.textContent = `• ${txt}`;
      }

      function connectSSE() {
        const v = validateInputs(true);
        if (!v) return;

        const sseUrl = `${v.base}/api/v1/gateway/simulate/${encodeURIComponent(
          v.msisdn,
        )}/get-otp`;
        line(`⇄ Connecting SSE: GET ${sseUrl}`, 'dim');

        // Abort any existing connection
        if (sseAbortController) {
          try {
            sseAbortController.abort();
          } catch {}
        }
        sseAbortController = new AbortController();
        setStatus('connecting…');

        fetch(sseUrl, {
          method: 'GET',
          headers: {
            Accept: 'text/event-stream',
            // Required by your server code
            'x-otp-simulation-token': v.token,
          },
          mode: 'cors',
          signal: sseAbortController.signal,
        })
          .then(async (res) => {
            if (!res.ok) {
              setStatus('error');
              line(`✗ SSE HTTP ${res.status} — unable to open stream.`, 'err');
              return;
            }
            setStatus('connected');
            const reader = res.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';

            // Basic SSE parser: events separated by \n\n, fields "event:", "data:", "id:", ":" (comment)
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });

              let idx;
              while ((idx = buffer.indexOf('\n\n')) !== -1) {
                const rawEvent = buffer.slice(0, idx);
                buffer = buffer.slice(idx + 2);
                handleSSEChunk(rawEvent);
              }
            }
            setStatus('disconnected');
            line('SSE connection closed.', 'dim');
          })
          .catch((err) => {
            if (err.name === 'AbortError') {
              setStatus('disconnected');
              line('SSE connection aborted by user.', 'dim');
            } else {
              setStatus('error');
              line(`✗ SSE error: ${err}`, 'err');
            }
          });
      }

      function handleSSEChunk(chunk) {
        // Ignore keep-alive comments
        if (/^:\s?.*/.test(chunk.trim())) {
          return; // keep-alive or comment
        }
        // Parse lines
        const lines = chunk.split('\n');
        const evt = { event: 'message', data: '', id: null };
        for (const l of lines) {
          if (!l) continue;
          if (l.startsWith('event:')) {
            evt.event = l.slice(6).trim();
          } else if (l.startsWith('data:')) {
            const dataLine = l.slice(5).trim();
            evt.data += (evt.data ? '\n' : '') + dataLine;
          } else if (l.startsWith('id:')) {
            evt.id = l.slice(3).trim();
          }
        }
        // Try to pretty print JSON data if possible
        let rendered = evt.data;
        try {
          const parsed = JSON.parse(evt.data);
          rendered = JSON.stringify(parsed.payload, null, 2);
        } catch {}
        const tag = evt.event ? `[${evt.event}]` : '[message]';
        line(`${tag}${evt.id ? ' #' + evt.id : ''}\n${rendered}`);
      }

      function disconnectSSE() {
        if (sseAbortController) {
          try {
            sseAbortController.abort();
          } catch {}
          sseAbortController = null;
        }
      }

      function clearLog() {
        logBox.innerHTML = '';
      }

      async function copyAll() {
        const text = Array.from(logBox.querySelectorAll('.line'))
          .map((d) => d.textContent)
          .join('\n');
        try {
          await navigator.clipboard.writeText(text);
          line('✓ Copied all logs to clipboard.', 'ok');
        } catch {
          line('✗ Unable to copy to clipboard.', 'err');
        }
      }

      function saveInputs() {
        const payload = {
          baseUrl: baseUrlEl.value || '',
          msisdn: msisdnEl.value || '',
          clientType: clientTypeEl.value || '',
          sseToken: sseTokenEl.value || '',
        };
        localStorage.setItem('otpToolInputs', JSON.stringify(payload));
        line('✓ Saved inputs to localStorage.', 'ok');
      }

      function loadInputs() {
        const raw = localStorage.getItem('otpToolInputs');
        if (!raw) {
          line('No saved inputs found.', 'dim');
          return;
        }
        try {
          const p = JSON.parse(raw);
          baseUrlEl.value = p.baseUrl || '';
          msisdnEl.value = p.msisdn || '';
          clientTypeEl.value = p.clientType || '';
          sseTokenEl.value = p.sseToken || '';
          line('✓ Loaded saved inputs.', 'ok');
        } catch {
          line('✗ Failed to parse saved inputs.', 'err');
        }
      }

      // Wire up
      sendOtpBtn.addEventListener('click', sendOtp);
      connectSseBtn.addEventListener('click', connectSSE);
      disconnectSseBtn.addEventListener('click', disconnectSSE);
      clearLogBtn.addEventListener('click', clearLog);
      copyBtn.addEventListener('click', copyAll);
      saveBtn.addEventListener('click', saveInputs);
      loadBtn.addEventListener('click', loadInputs);

      // Helpful defaults if you reload frequently
      loadInputs();
    </script>
  </body>
</html>
