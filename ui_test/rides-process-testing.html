<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Rides Module API Tester</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      body {
        margin: 0;
        padding: 24px;
        background: #0d1117;
        color: #f0f6fc;
      }
      h1,
      h2,
      h3 {
        margin-top: 0;
      }
      section {
        border: 1px solid #30363d;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
        background: rgba(13, 17, 23, 0.85);
      }
      label {
        display: block;
        font-size: 0.85rem;
        margin-bottom: 4px;
        color: #9da5b4;
      }
      input,
      button,
      textarea,
      select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        margin-bottom: 12px;
        border-radius: 6px;
        border: 1px solid #30363d;
        background: #161b22;
        color: inherit;
      }
      button {
        cursor: pointer;
        border: 1px solid #238636;
        background: #238636;
        font-weight: 600;
      }
      button.secondary {
        background: transparent;
        border-color: #30363d;
      }
      pre {
        background: #161b22;
        border: 1px solid #30363d;
        padding: 12px;
        border-radius: 6px;
        overflow: auto;
        max-height: 240px;
        font-size: 0.9rem;
        white-space: pre-wrap;
      }
      .stacked {
        display: grid;
        gap: 12px;
      }
      .inline {
        display: flex;
        gap: 8px;
      }
      .inline > * {
        flex: 1;
        margin-bottom: 0;
      }
      .badge {
        display: inline-flex;
        padding: 2px 6px;
        border-radius: 12px;
        background: #30363d;
        font-size: 0.75rem;
        color: #9da5b4;
        margin-left: 8px;
      }
      .muted {
        color: #8b949e;
        font-size: 0.85rem;
      }
      textarea {
        min-height: 120px;
      }
      fieldset {
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 12px;
      }
      fieldset legend {
        padding: 0 6px;
        font-size: 0.8rem;
        color: #8b949e;
      }
      .hint {
        font-size: 0.75rem;
        color: #8b949e;
        margin-top: -8px;
        margin-bottom: 12px;
      }
      .log {
        min-height: 160px;
      }
      .small-gap {
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <main class="stacked">
      <header>
        <h1>
          Rides Process Testing
          <span class="badge">Rides module</span>
        </h1>
        <p class="muted">
          Exercise every API exposed by the rides workflow through the gateway.
          Supply a valid bearer token for the relevant actor (rider or driver)
          and walk through requesting, accepting, and completing rides.
        </p>
      </header>

      <section>
        <h2>Environment</h2>
        <div class="stacked">
          <label for="baseUrl">Gateway base URL</label>
          <input
            id="baseUrl"
            type="url"
            value="http://localhost:3000/api/v1"
            placeholder="http://localhost:3000/api/v1"
          />
          <label for="authHeader">Authorization header</label>
          <input id="authHeader" type="text" placeholder="Bearer &lt;token&gt;" />
          <div class="inline small-gap">
            <div>
              <label for="rideId">Ride identifier (persisted between calls)</label>
              <input id="rideId" type="text" placeholder="uuid" />
            </div>
            <div>
              <label for="defaultDriverId">Default driver ID</label>
              <input id="defaultDriverId" type="text" placeholder="uuid" />
            </div>
          </div>
          <p class="hint">
            All endpoint paths below are relative to the base URL. Defaults are
            pre-filled for the <code>/gateway</code> controller routes.
          </p>
        </div>
      </section>

      <section>
        <h2>Stream ride notifications (SSE)</h2>
        <div class="stacked">
          <label for="streamPath">Endpoint path</label>
          <input
            id="streamPath"
            type="text"
            value="/gateway/notifications/stream"
            placeholder="/gateway/notifications/stream"
          />
          <div class="inline small-gap">
            <button id="connectStream">Connect</button>
            <button id="disconnectStream" class="secondary">Disconnect</button>
          </div>
          <pre id="streamResult" class="log">Stream idle.</pre>
        </div>
      </section>

      <section>
        <h2>Create ride (rider)</h2>
        <div class="stacked">
          <label for="createPath">Endpoint path</label>
          <input
            id="createPath"
            type="text"
            value="/gateway/rides"
            placeholder="/gateway/rides"
          />
          <fieldset>
            <legend>Pickup coordinate</legend>
            <div class="inline small-gap">
              <div>
                <label for="pickupLongitude">Longitude</label>
                <input id="pickupLongitude" type="number" step="any" />
              </div>
              <div>
                <label for="pickupLatitude">Latitude</label>
                <input id="pickupLatitude" type="number" step="any" />
              </div>
            </div>
          </fieldset>
          <fieldset>
            <legend>Dropoff coordinate</legend>
            <div class="inline small-gap">
              <div>
                <label for="dropoffLongitude">Longitude</label>
                <input id="dropoffLongitude" type="number" step="any" />
              </div>
              <div>
                <label for="dropoffLatitude">Latitude</label>
                <input id="dropoffLatitude" type="number" step="any" />
              </div>
            </div>
          </fieldset>
          <label for="note">Note (optional)</label>
          <input id="note" type="text" placeholder="Any extra instructions" />
          <label for="createDriverId">Driver ID (required by DTO)</label>
          <input id="createDriverId" type="text" placeholder="uuid" />
          <button id="createRide">Request ride</button>
          <pre id="createResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Retrieve ride details</h2>
        <div class="stacked">
          <label for="statusPath">Endpoint path</label>
          <input
            id="statusPath"
            type="text"
            value="/gateway/rides/{id}"
            placeholder="/gateway/rides/{id}"
          />
          <button id="fetchStatus">Fetch ride</button>
          <pre id="statusResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Driver responses</h2>
        <div class="stacked">
          <label for="driverAcceptPath">Driver accept endpoint</label>
          <input
            id="driverAcceptPath"
            type="text"
            value="/gateway/rides/{id}/driver-accept"
            placeholder="/gateway/rides/{id}/driver-accept"
          />
          <button id="driverAccept">Accept as driver</button>
          <pre id="driverAcceptResult">{}</pre>
          <label for="completePath">Complete ride endpoint</label>
          <input
            id="completePath"
            type="text"
            value="/gateway/rides/{id}/complete"
            placeholder="/gateway/rides/{id}/complete"
          />
          <button id="completeRide">Complete ride</button>
          <pre id="completeResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Rider responses</h2>
        <div class="stacked">
          <label for="riderAcceptPath">Rider accept endpoint</label>
          <input
            id="riderAcceptPath"
            type="text"
            value="/gateway/rides/{id}/rider-accept"
            placeholder="/gateway/rides/{id}/rider-accept"
          />
          <button id="riderAccept">Confirm driver</button>
          <pre id="riderAcceptResult">{}</pre>
          <label for="riderRejectPath">Rider reject endpoint</label>
          <input
            id="riderRejectPath"
            type="text"
            value="/gateway/rides/{id}/rider-reject"
            placeholder="/gateway/rides/{id}/rider-reject"
          />
          <label for="riderRejectReason">Reason (optional)</label>
          <input id="riderRejectReason" type="text" placeholder="Reason for rejection" />
          <button id="riderReject">Reject driver</button>
          <pre id="riderRejectResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Cancel ride (rider)</h2>
        <div class="stacked">
          <label for="cancelPath">Endpoint path</label>
          <input
            id="cancelPath"
            type="text"
            value="/gateway/rides/{id}/cancel"
            placeholder="/gateway/rides/{id}/cancel"
          />
          <label for="cancelReason">Reason (optional)</label>
          <input id="cancelReason" type="text" placeholder="Reason for cancelling" />
          <button id="cancelRide">Cancel ride</button>
          <pre id="cancelResult">{}</pre>
        </div>
      </section>
    </main>

    <script>
      const streamState = {
        controller: null,
        reader: null,
      };

      function $(id) {
        return document.getElementById(id);
      }

      function getBaseUrl() {
        const baseUrl = $('baseUrl').value.trim();
        return baseUrl.replace(/\/$/, '');
      }

      function getHeaders() {
        const headers = {
          'Content-Type': 'application/json',
        };
        const auth = $('authHeader').value.trim();
        if (auth) {
          headers.Authorization = auth;
        }
        return headers;
      }

      function getRideId() {
        return $('rideId').value.trim();
      }

      function setRideId(id) {
        if (!id) return;
        $('rideId').value = id;
      }

      function getDriverId() {
        return (
          $('createDriverId').value.trim() || $('defaultDriverId').value.trim()
        );
      }

      function stringify(result) {
        if (result instanceof Response) {
          return `${result.status} ${result.statusText}`;
        }
        if (typeof result === 'string') {
          return result;
        }
        try {
          return JSON.stringify(result, null, 2);
        } catch (error) {
          return String(result);
        }
      }

      async function request(path, options = {}) {
        let response;
        try {
          response = await fetch(`${getBaseUrl()}${path}`, {
            ...options,
            headers: {
              ...getHeaders(),
              ...(options.headers || {}),
            },
          });
        } catch (error) {
          const detail =
            error instanceof Error ? error.message : 'Unknown network failure';
          throw new Error(`Network request failed: ${detail}`);
        }

        let data;
        try {
          data = await response.clone().json();
        } catch (error) {
          data = await response.text();
        }
        return { response, data };
      }

      function display(targetId, payload) {
        const target = $(targetId);
        target.textContent = stringify(payload);
      }

      function resolvePath(templateId) {
        const template = $(templateId).value.trim();
        if (!template) {
          return '';
        }
        if (template.includes('{id}')) {
          const rideId = getRideId();
          if (!rideId) {
            return null;
          }
          return template.replace('{id}', rideId);
        }
        return template;
      }

      function extractRideId(data) {
        if (!data) return null;
        if (data?.data?.id) return data.data.id;
        if (data?.id) return data.id;
        return null;
      }

      function parseCoordinate(longitude, latitude, label) {
        const lng = Number(longitude.value);
        const lat = Number(latitude.value);
        if (!Number.isFinite(lng) || !Number.isFinite(lat)) {
          throw new Error(`${label} longitude and latitude must be numbers.`);
        }
        return { longitude: lng, latitude: lat };
      }

      $('createRide').addEventListener('click', async () => {
        const path = $('createPath').value.trim() || '/gateway/rides';
        const driverId = getDriverId();
        if (!driverId) {
          return display('createResult', 'Driver ID is required.');
        }
        let pickup;
        let dropoff;
        try {
          pickup = parseCoordinate(
            $('pickupLongitude'),
            $('pickupLatitude'),
            'Pickup',
          );
          dropoff = parseCoordinate(
            $('dropoffLongitude'),
            $('dropoffLatitude'),
            'Dropoff',
          );
        } catch (error) {
          return display('createResult', error instanceof Error ? error.message : String(error));
        }
        const payload = {
          pickup,
          dropoff,
          driverId,
        };
        const note = $('note').value.trim();
        if (note) {
          payload.note = note;
        }
        try {
          const { response, data } = await request(path, {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          display('createResult', data || response);
          setRideId(extractRideId(data));
        } catch (error) {
          display('createResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('fetchStatus').addEventListener('click', async () => {
        const path = resolvePath('statusPath');
        if (path === '') {
          return display('statusResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display(
            'statusResult',
            'Set the ride ID or replace {id} in the endpoint path.',
          );
        }
        try {
          const { response, data } = await request(path, { method: 'GET' });
          display('statusResult', data || response);
          setRideId(extractRideId(data));
        } catch (error) {
          display('statusResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('driverAccept').addEventListener('click', async () => {
        const path = resolvePath('driverAcceptPath');
        if (path === '') {
          return display('driverAcceptResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display(
            'driverAcceptResult',
            'Set the ride ID so {id} can be replaced.',
          );
        }
        try {
          const { response, data } = await request(path, { method: 'POST' });
          display('driverAcceptResult', data || response);
        } catch (error) {
          display(
            'driverAcceptResult',
            error instanceof Error ? error.message : String(error),
          );
        }
      });

      $('completeRide').addEventListener('click', async () => {
        const path = resolvePath('completePath');
        if (path === '') {
          return display('completeResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('completeResult', 'Set the ride ID before completing.');
        }
        try {
          const { response, data } = await request(path, { method: 'POST' });
          display('completeResult', data || response);
        } catch (error) {
          display('completeResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('riderAccept').addEventListener('click', async () => {
        const path = resolvePath('riderAcceptPath');
        if (path === '') {
          return display('riderAcceptResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('riderAcceptResult', 'Set the ride ID before accepting.');
        }
        try {
          const { response, data } = await request(path, { method: 'POST' });
          display('riderAcceptResult', data || response);
        } catch (error) {
          display('riderAcceptResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('riderReject').addEventListener('click', async () => {
        const path = resolvePath('riderRejectPath');
        if (path === '') {
          return display('riderRejectResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('riderRejectResult', 'Set the ride ID before rejecting.');
        }
        const reason = $('riderRejectReason').value.trim();
        const payload = reason ? { reason } : {};
        try {
          const { response, data } = await request(path, {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          display('riderRejectResult', data || response);
        } catch (error) {
          display('riderRejectResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('cancelRide').addEventListener('click', async () => {
        const path = resolvePath('cancelPath');
        if (path === '') {
          return display('cancelResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('cancelResult', 'Set the ride ID before cancelling.');
        }
        const reason = $('cancelReason').value.trim();
        const payload = reason ? { reason } : {};
        try {
          const { response, data } = await request(path, {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          display('cancelResult', data || response);
        } catch (error) {
          display('cancelResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('defaultDriverId').addEventListener('input', () => {
        if (!$('createDriverId').value.trim()) {
          $('createDriverId').value = $('defaultDriverId').value.trim();
        }
      });

      $('connectStream').addEventListener('click', async () => {
        if (streamState.controller) {
          return display('streamResult', 'Stream already connected.');
        }
        const path = $('streamPath').value.trim() || '/gateway/notifications/stream';
        const url = `${getBaseUrl()}${path}`;
        const headers = getHeaders();
        const controller = new AbortController();
        streamState.controller = controller;
        $('streamResult').textContent = 'Connecting to stream...';
        try {
          const response = await fetch(url, {
            method: 'GET',
            headers,
            signal: controller.signal,
          });
          if (!response.ok || !response.body) {
            streamState.controller = null;
            throw new Error(
              `Stream failed: ${response.status} ${response.statusText}`,
            );
          }
          const reader = response.body.getReader();
          streamState.reader = reader;
          const decoder = new TextDecoder('utf-8');
          let buffer = '';
          $('streamResult').textContent = 'Connected. Awaiting events...\n';
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const parts = buffer.split(/\r?\n\r?\n/);
            buffer = parts.pop() ?? '';
            for (const chunk of parts) {
              const lines = chunk
                .split(/\r?\n/)
                .map((line) => line.replace(/\r$/, ''))
                .filter((line) => line.trim().length > 0);
              if (!lines.length) continue;
              const eventLine = lines.find((line) => line.startsWith('event:'));
              const idLine = lines.find((line) => line.startsWith('id:'));
              const dataLines = lines
                .filter((line) => line.startsWith('data:'))
                .map((line) => line.replace(/^data:\s?/, '').trimStart());
              const payloadText = dataLines.join('\n');
              let parsed = payloadText;
              try {
                parsed = JSON.parse(payloadText);
              } catch (error) {
                // leave as text
              }
              const timestamp = new Date().toLocaleTimeString();
              const summary = {
                time: timestamp,
                event: eventLine ? eventLine.replace('event:', '').trim() : null,
                id: idLine ? idLine.replace('id:', '').trim() : null,
                data: parsed,
              };
              const current = $('streamResult').textContent;
              $('streamResult').textContent = `${current}${stringify(summary)}\n`;
              $('streamResult').scrollTop = $('streamResult').scrollHeight;
            }
          }
          $('streamResult').textContent += 'Stream closed.\n';
        } catch (error) {
          const message =
            error instanceof Error ? error.message : 'Unknown stream failure';
          $('streamResult').textContent += `${message}\n`;
        } finally {
          if (streamState.reader) {
            try {
              streamState.reader.cancel();
            } catch (_) {}
          }
          streamState.controller = null;
          streamState.reader = null;
        }
      });

      $('disconnectStream').addEventListener('click', () => {
        if (!streamState.controller) {
          return display('streamResult', 'Stream is not connected.');
        }
        streamState.controller.abort();
        $('streamResult').textContent += 'Disconnect requested.\n';
      });
    </script>
  </body>
</html>
