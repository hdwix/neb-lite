<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Rides Module API Tester</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      body {
        margin: 0;
        padding: 24px;
        background: #0d1117;
        color: #f0f6fc;
      }
      h1,
      h2,
      h3 {
        margin-top: 0;
      }
      section {
        border: 1px solid #30363d;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
        background: rgba(13, 17, 23, 0.85);
      }
      label {
        display: block;
        font-size: 0.85rem;
        margin-bottom: 4px;
        color: #9da5b4;
      }
      input,
      button,
      textarea,
      select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        margin-bottom: 12px;
        border-radius: 6px;
        border: 1px solid #30363d;
        background: #161b22;
        color: inherit;
      }
      button {
        cursor: pointer;
        border: 1px solid #238636;
        background: #238636;
        font-weight: 600;
      }
      button.secondary {
        background: transparent;
        border-color: #30363d;
      }
      pre {
        background: #161b22;
        border: 1px solid #30363d;
        padding: 12px;
        border-radius: 6px;
        overflow: auto;
        max-height: 240px;
        font-size: 0.9rem;
        white-space: pre-wrap;
      }
      .stacked {
        display: grid;
        gap: 12px;
      }
      .inline {
        display: flex;
        gap: 8px;
      }
      .inline > * {
        flex: 1;
        margin-bottom: 0;
      }
      .badge {
        display: inline-flex;
        padding: 2px 6px;
        border-radius: 12px;
        background: #30363d;
        font-size: 0.75rem;
        color: #9da5b4;
        margin-left: 8px;
      }
      .muted {
        color: #8b949e;
        font-size: 0.85rem;
      }
      textarea {
        min-height: 120px;
      }
      fieldset {
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 12px;
      }
      fieldset legend {
        padding: 0 6px;
        font-size: 0.8rem;
        color: #8b949e;
      }
      .hint {
        font-size: 0.75rem;
        color: #8b949e;
        margin-top: -8px;
        margin-bottom: 12px;
      }
      .log {
        min-height: 160px;
      }
      .small-gap {
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <main class="stacked">
      <header>
        <h1>
          Rides Process Testing
          <span class="badge">Rides module</span>
        </h1>
        <p class="muted">
          Exercise every API exposed by the rides workflow through the gateway.
          Supply a valid bearer token for the relevant actor (rider or driver)
          and walk through requesting, accepting, and completing rides.
        </p>
      </header>

      <section>
        <h2>Environment</h2>
        <div class="stacked">
          <label for="baseUrl">Gateway base URL</label>
          <input
            id="baseUrl"
            type="url"
            value="http://localhost:3000/api/v1"
            placeholder="http://localhost:3000/api/v1"
          />
          <label for="authHeader">Authorization header</label>
          <input id="authHeader" type="text" placeholder="Bearer &lt;token&gt;" />
          <div class="inline small-gap">
            <div>
              <label for="rideId">Ride identifier (persisted between calls)</label>
              <input id="rideId" type="text" placeholder="uuid" />
            </div>
            <div>
              <label for="defaultDriverId">Default driver ID</label>
              <input id="defaultDriverId" type="text" placeholder="uuid" />
            </div>
          </div>
          <p class="hint">
            All endpoint paths below are relative to the base URL. Defaults are
            pre-filled for the <code>/gateway</code> controller routes.
          </p>
        </div>
      </section>

      <section>
        <h2>Stream ride notifications (SSE)</h2>
        <div class="stacked">
          <label for="streamPath">Endpoint path</label>
          <input
            id="streamPath"
            type="text"
            value="/gateway/notifications/stream"
            placeholder="/gateway/notifications/stream"
          />
          <label for="streamMode">Connection mode</label>
          <select id="streamMode">
            <option value="auto" selected>Auto (prefer EventSource)</option>
            <option value="eventsource">EventSource (no custom headers)</option>
            <option value="fetch">Fetch (allows custom headers)</option>
          </select>
          <p class="hint">
            EventSource connections cannot send an <code>Authorization</code>
            header. Choose the fetch mode when you need to stream as an
            authenticated driver token.
          </p>
          <div class="inline small-gap">
            <button id="connectStream">Connect</button>
            <button id="disconnectStream" class="secondary">Disconnect</button>
          </div>
          <pre id="streamResult" class="log">Stream idle.</pre>
        </div>
      </section>

      <section>
        <h2>Create ride (rider)</h2>
        <div class="stacked">
          <label for="createPath">Endpoint path</label>
          <input
            id="createPath"
            type="text"
            value="/gateway/rides"
            placeholder="/gateway/rides"
          />
          <fieldset>
            <legend>Pickup coordinate</legend>
            <div class="inline small-gap">
              <div>
                <label for="pickupLongitude">Longitude</label>
                <input id="pickupLongitude" type="number" step="any" />
              </div>
              <div>
                <label for="pickupLatitude">Latitude</label>
                <input id="pickupLatitude" type="number" step="any" />
              </div>
            </div>
          </fieldset>
          <fieldset>
            <legend>Dropoff coordinate</legend>
            <div class="inline small-gap">
              <div>
                <label for="dropoffLongitude">Longitude</label>
                <input id="dropoffLongitude" type="number" step="any" />
              </div>
              <div>
                <label for="dropoffLatitude">Latitude</label>
                <input id="dropoffLatitude" type="number" step="any" />
              </div>
            </div>
          </fieldset>
          <label for="note">Note (optional)</label>
          <input id="note" type="text" placeholder="Any extra instructions" />
          <label for="createDriverId">Driver ID (required by DTO)</label>
          <input id="createDriverId" type="text" placeholder="uuid" />
          <button id="createRide">Request ride</button>
          <pre id="createResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Retrieve ride details</h2>
        <div class="stacked">
          <label for="statusPath">Endpoint path</label>
          <input
            id="statusPath"
            type="text"
            value="/gateway/rides/{id}"
            placeholder="/gateway/rides/{id}"
          />
          <button id="fetchStatus">Fetch ride</button>
          <pre id="statusResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Driver responses</h2>
        <div class="stacked">
          <label for="driverAcceptPath">Driver accept endpoint</label>
          <input
            id="driverAcceptPath"
            type="text"
            value="/gateway/rides/{id}/driver-accept"
            placeholder="/gateway/rides/{id}/driver-accept"
          />
          <button id="driverAccept">Accept as driver</button>
          <pre id="driverAcceptResult">{}</pre>
          <label for="completePath">Complete ride endpoint</label>
          <input
            id="completePath"
            type="text"
            value="/gateway/rides/{id}/complete"
            placeholder="/gateway/rides/{id}/complete"
          />
          <button id="completeRide">Complete ride</button>
          <pre id="completeResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Rider responses</h2>
        <div class="stacked">
          <label for="riderAcceptPath">Rider accept endpoint</label>
          <input
            id="riderAcceptPath"
            type="text"
            value="/gateway/rides/{id}/rider-accept"
            placeholder="/gateway/rides/{id}/rider-accept"
          />
          <button id="riderAccept">Confirm driver</button>
          <pre id="riderAcceptResult">{}</pre>
          <label for="riderRejectPath">Rider reject endpoint</label>
          <input
            id="riderRejectPath"
            type="text"
            value="/gateway/rides/{id}/rider-reject"
            placeholder="/gateway/rides/{id}/rider-reject"
          />
          <label for="riderRejectReason">Reason (optional)</label>
          <input id="riderRejectReason" type="text" placeholder="Reason for rejection" />
          <button id="riderReject">Reject driver</button>
          <pre id="riderRejectResult">{}</pre>
        </div>
      </section>

      <section>
        <h2>Cancel ride (rider)</h2>
        <div class="stacked">
          <label for="cancelPath">Endpoint path</label>
          <input
            id="cancelPath"
            type="text"
            value="/gateway/rides/{id}/cancel"
            placeholder="/gateway/rides/{id}/cancel"
          />
          <label for="cancelReason">Reason (optional)</label>
          <input id="cancelReason" type="text" placeholder="Reason for cancelling" />
          <button id="cancelRide">Cancel ride</button>
          <pre id="cancelResult">{}</pre>
        </div>
      </section>
    </main>

    <script>
      const KNOWN_STREAM_EVENTS = [
        'message',
        'ride.candidates.invited',
        'ride.offer',
        'ride.driver.accepted',
        'ride.driver.declined',
        'ride.rider.confirmed',
        'ride.rider.rejected',
        'ride.driver.not_selected',
        'ride.cancelled',
        'otp.generated',
      ];

      const streamState = {
        controller: null,
        reader: null,
        source: null,
      };

      function resetStreamLog(message) {
        const target = $('streamResult');
        target.textContent = `${message}\n`;
        target.scrollTop = target.scrollHeight;
      }

      function appendStreamLog(entry) {
        const target = $('streamResult');
        if (!target.textContent.endsWith('\n')) {
          target.textContent += '\n';
        }
        target.textContent += `${entry}\n`;
        target.scrollTop = target.scrollHeight;
      }

      function parseEventData(raw) {
        if (raw === undefined || raw === null) {
          return raw;
        }
        if (typeof raw !== 'string') {
          return raw;
        }
        const trimmed = raw.trim();
        if (!trimmed) {
          return '';
        }
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          return raw;
        }
      }

      function logStreamEvent(eventName, id, rawData) {
        const summary = {
          time: new Date().toLocaleTimeString(),
          event: eventName ?? null,
          id: id ?? null,
          data: parseEventData(rawData),
        };
        appendStreamLog(stringify(summary));
      }

      function $(id) {
        return document.getElementById(id);
      }

      function getBaseUrl() {
        const baseUrl = $('baseUrl').value.trim();
        return baseUrl.replace(/\/$/, '');
      }

      function getHeaders(options = {}) {
        const { includeJson = true } = options;
        const headers = {};
        if (includeJson) {
          headers['Content-Type'] = 'application/json';
        }
        const auth = $('authHeader').value.trim();
        if (auth) {
          headers.Authorization = auth;
        }
        return headers;
      }

      function getRideId() {
        return $('rideId').value.trim();
      }

      function setRideId(id) {
        if (!id) return;
        $('rideId').value = id;
      }

      function getDriverId() {
        return (
          $('createDriverId').value.trim() || $('defaultDriverId').value.trim()
        );
      }

      function stringify(result) {
        if (result instanceof Response) {
          return `${result.status} ${result.statusText}`;
        }
        if (typeof result === 'string') {
          return result;
        }
        try {
          return JSON.stringify(result, null, 2);
        } catch (error) {
          return String(result);
        }
      }

      async function request(path, options = {}) {
        let response;
        try {
          const includeJson =
            options.body !== undefined ||
            (options.method ? options.method !== 'GET' : false);
          response = await fetch(`${getBaseUrl()}${path}`, {
            ...options,
            headers: {
              ...getHeaders({ includeJson }),
              ...(options.headers || {}),
            },
          });
        } catch (error) {
          const detail =
            error instanceof Error ? error.message : 'Unknown network failure';
          throw new Error(`Network request failed: ${detail}`);
        }

        let data;
        try {
          data = await response.clone().json();
        } catch (error) {
          data = await response.text();
        }
        return { response, data };
      }

      function display(targetId, payload) {
        const target = $(targetId);
        target.textContent = stringify(payload);
      }

      function resolvePath(templateId) {
        const template = $(templateId).value.trim();
        if (!template) {
          return '';
        }
        if (template.includes('{id}')) {
          const rideId = getRideId();
          if (!rideId) {
            return null;
          }
          return template.replace('{id}', rideId);
        }
        return template;
      }

      function extractRideId(data) {
        if (!data) return null;
        if (data?.data?.id) return data.data.id;
        if (data?.id) return data.id;
        return null;
      }

      function parseCoordinate(longitude, latitude, label) {
        const lng = Number(longitude.value);
        const lat = Number(latitude.value);
        if (!Number.isFinite(lng) || !Number.isFinite(lat)) {
          throw new Error(`${label} longitude and latitude must be numbers.`);
        }
        return { longitude: lng, latitude: lat };
      }

      $('createRide').addEventListener('click', async () => {
        const path = $('createPath').value.trim() || '/gateway/rides';
        const driverId = getDriverId();
        if (!driverId) {
          return display('createResult', 'Driver ID is required.');
        }
        let pickup;
        let dropoff;
        try {
          pickup = parseCoordinate(
            $('pickupLongitude'),
            $('pickupLatitude'),
            'Pickup',
          );
          dropoff = parseCoordinate(
            $('dropoffLongitude'),
            $('dropoffLatitude'),
            'Dropoff',
          );
        } catch (error) {
          return display('createResult', error instanceof Error ? error.message : String(error));
        }
        const payload = {
          pickup,
          dropoff,
          driverId,
        };
        const note = $('note').value.trim();
        if (note) {
          payload.note = note;
        }
        try {
          const { response, data } = await request(path, {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          display('createResult', data || response);
          setRideId(extractRideId(data));
        } catch (error) {
          display('createResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('fetchStatus').addEventListener('click', async () => {
        const path = resolvePath('statusPath');
        if (path === '') {
          return display('statusResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display(
            'statusResult',
            'Set the ride ID or replace {id} in the endpoint path.',
          );
        }
        try {
          const { response, data } = await request(path, { method: 'GET' });
          display('statusResult', data || response);
          setRideId(extractRideId(data));
        } catch (error) {
          display('statusResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('driverAccept').addEventListener('click', async () => {
        const path = resolvePath('driverAcceptPath');
        if (path === '') {
          return display('driverAcceptResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display(
            'driverAcceptResult',
            'Set the ride ID so {id} can be replaced.',
          );
        }
        try {
          const { response, data } = await request(path, { method: 'POST' });
          display('driverAcceptResult', data || response);
        } catch (error) {
          display(
            'driverAcceptResult',
            error instanceof Error ? error.message : String(error),
          );
        }
      });

      $('completeRide').addEventListener('click', async () => {
        const path = resolvePath('completePath');
        if (path === '') {
          return display('completeResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('completeResult', 'Set the ride ID before completing.');
        }
        try {
          const { response, data } = await request(path, { method: 'POST' });
          display('completeResult', data || response);
        } catch (error) {
          display('completeResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('riderAccept').addEventListener('click', async () => {
        const path = resolvePath('riderAcceptPath');
        if (path === '') {
          return display('riderAcceptResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('riderAcceptResult', 'Set the ride ID before accepting.');
        }
        try {
          const { response, data } = await request(path, { method: 'POST' });
          display('riderAcceptResult', data || response);
        } catch (error) {
          display('riderAcceptResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('riderReject').addEventListener('click', async () => {
        const path = resolvePath('riderRejectPath');
        if (path === '') {
          return display('riderRejectResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('riderRejectResult', 'Set the ride ID before rejecting.');
        }
        const reason = $('riderRejectReason').value.trim();
        const payload = reason ? { reason } : {};
        try {
          const { response, data } = await request(path, {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          display('riderRejectResult', data || response);
        } catch (error) {
          display('riderRejectResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('cancelRide').addEventListener('click', async () => {
        const path = resolvePath('cancelPath');
        if (path === '') {
          return display('cancelResult', 'Provide an endpoint path.');
        }
        if (path === null) {
          return display('cancelResult', 'Set the ride ID before cancelling.');
        }
        const reason = $('cancelReason').value.trim();
        const payload = reason ? { reason } : {};
        try {
          const { response, data } = await request(path, {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          display('cancelResult', data || response);
        } catch (error) {
          display('cancelResult', error instanceof Error ? error.message : String(error));
        }
      });

      $('defaultDriverId').addEventListener('input', () => {
        if (!$('createDriverId').value.trim()) {
          $('createDriverId').value = $('defaultDriverId').value.trim();
        }
      });

      function connectEventSource(url) {
        resetStreamLog(`Connecting to ${url} (EventSource)...`);
        if (typeof EventSource === 'undefined') {
          appendStreamLog('EventSource API is not available in this browser.');
          return;
        }
        try {
          const source = new EventSource(url, { withCredentials: true });
          streamState.source = source;
          const handleEvent = (event) => {
            logStreamEvent(event.type || 'message', event.lastEventId ?? null, event.data);
          };
          const eventsToWatch = new Set(KNOWN_STREAM_EVENTS);
          eventsToWatch.add('message');
          for (const eventName of eventsToWatch) {
            source.addEventListener(eventName, handleEvent);
          }
          appendStreamLog(
            `Listening for events: ${Array.from(eventsToWatch).join(', ')}`,
          );
          source.addEventListener('open', () => {
            appendStreamLog('Connection established.');
          });
          source.addEventListener('error', (event) => {
            if (source.readyState === EventSource.CLOSED) {
              appendStreamLog('Stream closed by server.');
              streamState.source = null;
              return;
            }
            logStreamEvent(
              event.type || 'error',
              null,
              `Stream error (readyState: ${source.readyState}).`,
            );
          });
        } catch (error) {
          const message =
            error instanceof Error ? error.message : 'Failed to initialize EventSource';
          appendStreamLog(message);
          streamState.source = null;
        }
      }

      async function connectStreamWithFetch(url, headers, options = {}) {
        const { reason, connectLabel = 'fetch fallback' } = options;
        resetStreamLog(`Connecting to stream (${connectLabel})...`);
        if (reason) {
          appendStreamLog(reason);
        }
        const controller = new AbortController();
        streamState.controller = controller;
        try {
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              ...headers,
              Accept: 'text/event-stream',
              'Cache-Control': 'no-cache',
            },
            signal: controller.signal,
            mode: 'cors',
            credentials: 'include',
            cache: 'no-store',
          });
          if (!response.ok || !response.body) {
            streamState.controller = null;
            throw new Error(
              `Stream failed: ${response.status} ${response.statusText}`,
            );
          }
          const reader = response.body.getReader();
          streamState.reader = reader;
          const decoder = new TextDecoder('utf-8');
          let buffer = '';
          appendStreamLog(
            `Connected (HTTP ${response.status}). Awaiting events...`,
          );
          appendStreamLog('Listening for events using generic SSE parser.');
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              appendStreamLog('Stream ended by server.');
              break;
            }
            buffer += decoder.decode(value, { stream: true });
            const parts = buffer.split(/\r?\n\r?\n/);
            buffer = parts.pop() ?? '';
            for (const chunk of parts) {
              const lines = chunk.split(/\r?\n/).map((line) => line.replace(/\r$/, ''));
              let eventName = 'message';
              let eventId = null;
              const dataLines = [];
              for (const line of lines) {
                if (!line || line.startsWith(':')) {
                  continue;
                }
                if (line.startsWith('event:')) {
                  const valuePart = line.slice('event:'.length).trim();
                  if (valuePart) {
                    eventName = valuePart;
                  }
                } else if (line.startsWith('id:')) {
                  const valuePart = line.slice('id:'.length).trim();
                  if (valuePart) {
                    eventId = valuePart;
                  }
                } else if (line.startsWith('data:')) {
                  dataLines.push(line.slice('data:'.length).trimStart());
                }
              }
              const payloadText = dataLines.join('\n');
              logStreamEvent(eventName, eventId, payloadText);
            }
          }
        } catch (error) {
          if (controller.signal.aborted) {
            appendStreamLog('Stream aborted by client.');
          } else {
            const message =
              error instanceof Error ? error.message : 'Unknown stream failure';
            appendStreamLog(message);
          }
        } finally {
          if (streamState.reader) {
            try {
              streamState.reader.cancel();
            } catch (_) {}
          }
          streamState.controller = null;
          streamState.reader = null;
        }
      }

      $('connectStream').addEventListener('click', async () => {
        if (streamState.source || streamState.controller) {
          appendStreamLog('Stream already connected.');
          return;
        }
        const path = $('streamPath').value.trim() || '/gateway/notifications/stream';
        const baseUrl = getBaseUrl();
        const url = path.startsWith('/') ? `${baseUrl}${path}` : `${baseUrl}/${path}`;
        const headers = getHeaders({ includeJson: false });
        const authHeader = headers.Authorization;
        const mode = $('streamMode').value;

        const canUseEventSource = typeof EventSource !== 'undefined';
        const preferEventSource = mode === 'eventsource' || mode === 'auto';
        const wantsFetch = mode === 'fetch';

        if (preferEventSource && !canUseEventSource) {
          appendStreamLog('EventSource API unavailable in this browser.');
        }

        if (wantsFetch || !canUseEventSource) {
          const reason = wantsFetch
            ? 'Fetch mode selected manually.'
            : 'EventSource API unavailable; using fetch fallback.';
          await connectStreamWithFetch(url, headers, {
            reason,
            connectLabel: wantsFetch ? 'fetch (manual)' : 'fetch fallback',
          });
          return;
        }

        if (authHeader && preferEventSource) {
          appendStreamLog(
            'Authorization header detected. EventSource requests cannot include custom headers; use fetch mode if authentication is required.',
          );
        }

        if (!authHeader && preferEventSource) {
          connectEventSource(url);
          return;
        }

        await connectStreamWithFetch(url, headers, {
          reason:
            'Authorization header present; using fetch to forward custom headers.',
        });
      });

      $('disconnectStream').addEventListener('click', () => {
        if (streamState.source) {
          streamState.source.close();
          streamState.source = null;
          appendStreamLog('Disconnect requested.');
          return;
        }
        if (streamState.controller) {
          streamState.controller.abort();
          appendStreamLog('Disconnect requested.');
          return;
        }
        appendStreamLog('Stream is not connected.');
      });
    </script>
  </body>
</html>
